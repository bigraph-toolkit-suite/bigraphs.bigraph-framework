---
id: index
sidebar_label: Introduction
title: Welcome to Bigraph Framework
sidebar_position: 1
---

import useDocusaurusContext from '@docusaurus/useDocusaurusContext';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<center>
    <p>
        This manual provides a complete guide to the Bigraph Framework. <br/>
        <i>Last Updated: 2025-05-30</i>
    </p>
</center>


- **Stable**: <span class="badge badge-secondary" style={{backgroundColor: '#19c37d'}}>2.1.0</span> (main branch)
- Previous Stable Versions: 2.0.2, 2.0.1
- Latest Experimental Version: <span class="badge badge-secondary" style={{backgroundColor: '#7952b3'}}>3.0.0-SNAPSHOT</span> (develop branch)

<details style={{ background: 'transparent' }}>
    <summary><strong>Version Compatibility</strong></summary>

This table specifies the metamodel standards supported by the Bigraph Framework.

<table border="0">
        <tr>
            <th>Bigraph Framework</th>
            <th>Bigraph Ecore Metamodel</th>
        </tr>
        <tr>
            <td>1.0.0</td>
            <td>1.6.0</td>
        </tr>
        <tr>
            <td>1.1.0</td>
            <td>1.6.1</td>
        </tr>
        <tr>
            <td>2.0.1, 2.0.2, 2.1.0</td>
            <td>2.0.1, 1.6.1</td>
        </tr>
</table>

</details>

:::info Notice
This documentation reflects the latest experimental version.
:::

:::caution Caution
Since version 1.0.0 of Bigraph Framework: The new groupID and base package name `org.bigraphs.*` is used instead of the former one
`de.tudresden.inf.st.bigraphs.*`.
:::

## What is Bigraph Framework?

**Bigraph Framework** is a software framework
written in Java for the creation and simulation of bigraphs and bigraphical reactive systems
to expedite the experimental evaluation of the bigraph theory in real-world applications.

The goal of this framework is to facilitate the implementation of reactive systems, including context-aware, agent-based systems or cyber-physical systems.
The high level API eases the programming of bigraphical systems for various applications.
The framework is developed around a [metamodel-first approach](https://github.com/bigraph-toolkit-suite/bigraphs.bigraph-ecore-metamodel), when working with bigraphical structures.

### Features

- Modelling and Storage
    - Dynamic creation of bigraphs at design time and runtime based on the [Bigraph Ecore Metamodel (BEM)](https://github.com/bigraph-toolkit-suite/bigraphs.bigraph-ecore-metamodel)
    - Read and write instance models and metamodels of a bigraph from and to the file system
- Visualization
    - Graphical export via GraphViz/DOT
    - PNG, JPG, ...
    - Interactive visualization UI via GraphStream
    - Visualization of Compiler Graphs (VCG) format via yComp
- Bigraphical Reactive Systems (BRS): Simulate the evolution of bigraphs by reaction rules
    - Bigraph matching and rewriting via jLibBig
    - Generation of a labeled transition system (LTS)
    - Simulation and Model Checking (BFS, Random)
    - Predicate checking, logical connectors, LTL
    - Specify order of reaction rules via priorities
    - Conditional rules (not yet integrated in model checking procedure but available for custom usage)
    - Tracking rules (a rule can be assigned a tracking map)
- Model Importer/Exporter
    - Export a bigraph to common graph formats, e.g., DOT, GraphML, GXL, VCG
    - Export to formats of other bigraph tools: BigMC, BigraphER, BigRed, jLibBig, ...
    - Translate bigraphs to other graph classes: Ranked Graphs, multigraphs, ...
- Attributed Bigraphs
    - Add arbitrary attributes to nodes
    - Attributes are preserved when doing rewriting (this requires tracking maps)

### What are Bigraphs?

**Bigraphs** are an emerging theory and metamodel for global ubiquitous systems,
mobile computing, context-aware systems and the Internet of Things (IoT), or in general: for reactive systems.
It is grounded on category theory and regarded as a unifying framework for many process calculi, including the ambient calculus, action calculi, Petri nets,
the Calculus of Communicating Systems (CCS) and Ï€-calculus.
The theory provides an algebra and a graph rewriting mechanism to describe, study and analyze the dynamic behavior of reactive systems.

## Usage and Development Requirements

- Java >=17
- Maven v3.8.3 or Gradle


## Use / Install / Dependency Settings

Bigraph Framework is online available as Maven dependency.

Artifacts are deployed to the _Central Repository_.

:::tip Building from Source
To build the source by yourself, follow the [README.md](https://github.com/bigraph-toolkit-suite/bigraphs.bigraph-framework/blob/main/README.md) inside the code repository.
:::

### Quick Start: Starter Project Template

To get started using Bigraph Framework right away, download the Maven-based Project Skeleton

- [Starter Project Template using Bigraph Framework](https://www.bigraphs.org/products/bigraph-framework/download/Project-Skeleton-for-Bigraph-Framework.zip)
- See <a href={`https://github.com/bigraph-toolkit-suite/Project-Skeleton-for-Bigraph-Framework`}>here</a> for the latest version on GitHub

The README contained therein, describes how to compile and start an application.

Alternatively, follow the step-by-step project setup as described in the following.

### Package Dependencies

Depending on the build management tool you are using, one of the following
configuration for Maven or Gradle is necessary.

import * as myConstClass from "../src/components/BigraphDependencyBlock";
import * as myConstClass2 from "../src/components/BigraphRepositoryBlock";

<Tabs>
    <TabItem value="maven" label="Maven" default>
        Add this inside the <code>dependencies</code> section of your project's <code>*.pom</code> file.
        Replace VERSION with the latest version.
        <br/>
        <br/>
        <pre>
    {myConstClass.MAVEN_DEP_CODE}
    </pre>
    </TabItem>
    <TabItem value="gradle" label="Gradle">
        Append this in your <code>build.gradle</code> file.
        Replace VERSION with the latest version.
        <br/>
        <br/>
        <pre>{myConstClass.GRADLE_DEP_CODE}</pre>
    </TabItem>
    <TabItem value="manually" label="Manually">
        Manual setup is not recommended.
        Refer to the <a href={"https://github.com/bigraph-toolkit-suite/bigraphs.bigraph-framework/blob/main/README.md"}>README.md</a> in Bigraph Framework's code repository on how to build the framework from source.
    </TabItem>
</Tabs>

### Repository Setup for SNAPSHOT Releases

No additional configuration is necessary to resolve the dependencies above!

However, if you want SNAPSHOT releases, the following custom repository must be added as well.
The configuration for Maven and Gradle is provided below.

<Tabs>
    <TabItem value="maven" label="Maven" default>
        The following Maven repository entry must be added to the <code>repositories</code> element of a <code>pom.xml</code> of a Maven-based Java project:
        <pre>{myConstClass2.MAVEN_REP_CODE}</pre>
    </TabItem>
    <TabItem value="gradle" label="Gradle">
        For Gradle, add this to the project's build gradle file:
        <pre>{myConstClass2.GRADLE_REP_CODE}</pre>
    </TabItem>
</Tabs>

### Logging Configuration

Bigraph Framework employs SLF4J as a facade for the log4j logging framework.

Depending on your project setup, you may need to include the following libraries in your `pom.xml`:

```xml
<dependencies>
    <!-- For any Maven project in general -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>2.0.9</version>
    </dependency>
    <!-- Use a no-operation (NOP) logger implementation -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-nop</artifactId>
        <version>2.0.7</version>
    </dependency>
    <!-- or, for example, the reload4j implementation (fork of log4j) -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-reload4j</artifactId>
        <version>2.0.9</version>
    </dependency>

    <!-- When used within a Spring project -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-logging</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-log4j2</artifactId>
    </dependency>
</dependencies>
```

Not including these dependencies will result in warnings.
The example above shows how to use a NOP logger or a reload4j as the underlying logging framework in your project.
