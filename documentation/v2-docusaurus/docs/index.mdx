---
id: index
sidebar_label: Introduction
title: Welcome to Bigraph Framework
sidebar_position: 1
---

import useDocusaurusContext from '@docusaurus/useDocusaurusContext';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

A Complete Guide to the Bigraph Framework.

- Stable: <span class="badge badge-secondary" style={{backgroundColor: '#19c37d'}}>1.1.0</span> (main branch)
    - Previous Stable Versions: 1.0.0, 0.9.7, 0.9.6
- Latest Version: <span class="badge badge-secondary" style={{backgroundColor: '#7952b3'}}>1.0.0-SNAPSHOT</span> (develop branch)


:::info Notice
The API is subject to change. Use at your own risk.
This documentation reflects always the latest version.
:::

:::caution Caution
Since version 1.0.0 of Bigraph Framework: The new groupID and base package name `org.bigraphs.*` is used instead of the former one
`de.tudresden.inf.st.bigraphs.*`.
:::

## What is Bigraph Framework

**Bigraph Framework** is a Java software framework for the creation and simulation of bigraphs and bigraphical reactive systems
to expedite the experimental evaluation of the bigraph theory in real-world applications.

The goal of this framework is to facilitate the implementation of context-aware, agent-based systems or cyber-physical systems, for instance.
The high level API eases the programming of bigraphical systems for various real-world application.
The framework is developed around a [metamodel-first approach](https://github.com/bigraph-toolkit-suite/bigraphs.bigraph-ecore-metamodel), when working with bigraphical structures.
Incorporating the bigraph theory into software is accomplished through a variety of model-driven software development means.

### Overview of the Features

- Dynamic creation of bigraphs at runtime, which are based on the [Ecore metamodel of bigraphs](https://github.com/bigraph-toolkit-suite/bigraphs.bigraph-ecore-metamodel)
- Visualization of bigraphs
- Bigraph Matching and Rewriting via jLibBig
- Bigraphical Reactive Systems
    - Simulation of bigraphs by reaction rules
    - Synthesisation of a labelled transition system, or reaction graph
- Model Checking via simple bigraphical predicates, logical connectors, LTL is implicitly supported
- Read and write metamodels and instance models to the file system (Ecore/XMI)
- Conversion of bigraphs into other file formats
    - e.g., GraphML, BigMC, BigRED, BigraphER, ...

### What are Bigraphs?

**Bigraphs** are an emerging theory and metamodel for global ubiquitous systems,
mobile computing, context-aware systems and the Internet of Things (IoT), or in general: for reactive systems.
It is grounded on category theory and regarded as a unifying framework for many process calculi, including the ambient calculus, action calculi, Petri nets,
the Calculus of Communicating Systems (CCS) and Ï€-calculus.
The theory provides an algebra and a graph-rewriting-like mechanism to describe, study and analyze the dynamic behavior of reactive systems.

## Requirements

- Java 17
- Maven or Gradle
    - Minimum version of Maven: 3.8.3


## Use / Install / Dependency Settings

Bigraph Framework and its parts are online available as Maven dependencies.

Artifacts are deployed to the _Central Repository_.

:::tip Building from Source
Otherwise, to build the source by yourself, follow the [README.md](https://github.com/bigraph-toolkit-suite/bigraphs.bigraph-framework/blob/main/README.md) inside the code repository.
:::

### Quick Start: Empty Project Skeleton

To get started using Bigraph Framework right away, download the Maven-based Project Skeleton

- [Empty Project Skeleton for using Bigraph Framework](https://www.bigraphs.org/products/bigraph-framework/download/empty-project-skeleton-bigraphframework.zip)

The README contained therein, describes how to compile and start an application.

Alternatively, follow the step-by-step project setup as described in the following.

### Package Dependencies

Depending on the build management tool you are using, one of the following
configuration for Maven or Gradle is necessary.

import * as myConstClass from "../src/components/BigraphDependencyBlock";
import * as myConstClass2 from "../src/components/BigraphRepositoryBlock";

<Tabs>
  <TabItem value="maven" label="Maven" default>
    Add this inside the <code>dependencies</code> section of your project's <code>*.pom</code> file.
    Replace VERSION with the latest version.
      <br/>
      <br/>
    <pre>
    {myConstClass.MAVEN_DEP_CODE}
    </pre>
  </TabItem>
  <TabItem value="gradle" label="Gradle">
    Append this in your <code>build.gradle</code> file.
    Replace VERSION with the latest version.
      <br/>
      <br/>
    <pre>{myConstClass.GRADLE_DEP_CODE}</pre>
  </TabItem>
  <TabItem value="manually" label="Manually">
    Manual setup is not recommended.
    Refer to the <a href={"https://github.com/bigraph-toolkit-suite/bigraphs.bigraph-framework/blob/main/README.md"}>README.md</a> in Bigraph Framework's code repository on how to build the framework from source.
  </TabItem>
</Tabs>

### Repository Setup for SNAPSHOT Releases

No additional configuration is necessary to resolve the dependencies above!

However, if you want SNAPSHOT releases, the following custom repository must be added as well.
We provide the configuration for Maven and Gradle below.

<Tabs>
  <TabItem value="maven" label="Maven" default>
    The following Maven repository entry must be added to the <code>repositories</code> element of a <code>pom.xml</code> of a Maven-based Java project:
    <pre>
    {myConstClass2.MAVEN_REP_CODE}
    </pre>
    <br/>

[//]: # (Another option is to modify the <code>settings.xml</code>, usually found in <code>~/.m2/</code>.)

[//]: # (<pre>)

[//]: # ({myConstClass2.MAVEN_REP_CODE2})

[//]: # (</pre>)
  </TabItem>
  <TabItem value="gradle" label="Gradle">
    For Gradle, add this to the project's build gradle file:
    <pre>{myConstClass2.GRADLE_REP_CODE}</pre>
  </TabItem>
</Tabs>

### Logging Configuration

Bigraph Framework employs SLF4J as a facade for the log4j logging framework.

Depending on your project setup, you may need to include the following libraries in your `pom.xml`:

```xml
<!-- For any Maven project in general -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>2.0.9</version>
</dependency>
<!-- Use a no-operation (NOP) logger implementation -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-nop</artifactId>
    <version>2.0.7</version>
</dependency>
<!-- or, for example, the reload4j implementation (fork of log4j) -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-reload4j</artifactId>
    <version>2.0.9</version>
</dependency>

<!-- When used within a Spring project -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>
```

Not including these dependencies will result in warnings.
The example above shows how to use a NOP logger or a reload4j as the underlying logging framework in your project.
