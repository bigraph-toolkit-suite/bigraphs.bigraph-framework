# Signature
ctrl Room = 1;
ctrl User = 1;
ctrl User2 = 0;
ctrl Spool = 1;
ctrl Printer = 2;
ctrl Computer = 1;
ctrl Job = 0;

//occurrences: idle edges werden auch gezÃ¤hlt: wenn redex ein name hat, dann kann das mit einer idle edge im agent gematched werden

big s1 = /no /no2 /door (
(Room{door} . (Computer{no}.1 | User{no2}.1 | Computer{a}.(Job.1 | Job.(Job.1) | Job.1) | Computer{a}.1 | Computer{jeff1}.1 | Job.1 )) 
| (Spool{espool}.1) 
| (Room{eroom} . (User{jeff2}.(Job.1 | Job.1) | Job.1 | Job.1))
);

# big s1 = /door (
#   (Room{door} . (Computer{a}.1 | Computer{a}.(Job.1 | Job.(Job.1) | Job.1) | Computer{a}.1 | Computer{a}.1 | Computer{jeff1}.(Job.1) | Job.1 | User2.1 )) 
#   | (Spool{espool}.1) 
#   | (Room{eroom} . (User{door}.(Job.1 | Job.1) | Job.1 | Job.1))
# );

# big zweiA = (Computer{b1}.(id(1)) | Computer{jeff1}.1 | Job.1) || (User{jeff1}.(Job.1 | Job.1)); # matched nicht
big zweiB = (Computer{b1}.(id(1)) | Computer{c}.1 | Job.1) || (User{jeff1}.(Job.1 | Job.1)); # matched
# big zweiBReactum = (Computer{b1}.(id(1) | User2.1) | Computer{c}.1 | Job.1) || (User{jeff1}.(Job.1 | Job.1)); # allows maaaany possible reactions, is not distinct

# react react2A = zweiA -> zweiA;
react react2B = zweiB -> zweiB;

# big klo = Job * 1;

# Reactive system
begin brs
  init s1;
  rules = [{react2B}];
end
